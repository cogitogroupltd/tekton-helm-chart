# cd examples/buildah-build-deploy
# source ../../.env
# export SSH_KEY_LOCATION=../../.auth/id_rsa
# docker_auth="$(echo -n "${CONTAINER_REGISTRY_USERNAME}":"${CONTAINER_REGISTRY_PASSWORD}" | base64)"
# tee "config.json" > /dev/null <<EOF
# {"auths":{"https://index.docker.io/v1/":{"auth":"$docker_auth","email":"systems@cogitogroup.co.uk"}}}
# EOF
# helm upgrade --install pipelines -n tekton-resources --create-namespace tekton/pipeline --set github_token="$(echo -n "ENTERTOKEN" | base64)" --set secret_ssh_key="$(cat $SSH_KEY_LOCATION)" --set-file=docker_config_json=config.json --values ./values-override.yaml
---
# Source: pipeline/templates/cronjob.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "pipelines-tekton-cleanup"
  namespace: tekton-resources
---
# Source: pipeline/templates/global/serviceAccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "pipelines-tekton-default-sa"
---
# Source: pipeline/templates/triggers/role.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "pipelines-tekton-triggers-sa"
  namespace: tekton-resources
---
# Source: pipeline/templates/create-webhook/secret-github.yaml
apiVersion: v1
kind: Secret
metadata:
  name: github-secret
  namespace: tekton-resources
data:
  token: UlU1VVJWSlVUMHRGVGc9PQ==
  secret: UlU1VVJWSlVUMHRGVGc9PQ==
---
# Source: pipeline/templates/git-clone/secrets.yaml
kind: Secret
apiVersion: v1
metadata:
  name: "pipelines-ssh-key"
  namespace: tekton-resources
data:
  id_rsa: 
---
# Source: pipeline/templates/kaniko-build/secret-docker-config.yaml
apiVersion: v1
kind: Secret
type: generic
metadata:
  name: "pipelines-docker-config"
  namespace: tekton-resources
data:
  config.json: eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsiYXV0aCI6Ik9nPT0iLCJlbWFpbCI6InN5c3RlbXNAY29naXRvZ3JvdXAuY28udWsifX19Cg==
---
# Source: pipeline/templates/triggers/github-token.yaml
apiVersion: v1
kind: Secret
metadata:
  name: github-token
  namespace: tekton-resources
type: Opaque
data:
  token: UlU1VVJWSlVUMHRGVGc9PQ==
---
# Source: pipeline/templates/cronjob.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
  name: pipelines-tekton-cleanup-cm
  namespace: tekton-resources
data:
  runtimeConfig.sh: |
    kubectl get pvc -n tekton-resources | awk '{print $1}' | xargs kubectl delete pvc -n tekton-resources
---
# Source: pipeline/templates/rolling-update/cm-kubeconfig.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: "pipelines-kube-config"
  namespace: tekton-resources
data:
  kubeconfig: |-
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: DUMMY
        server: https://A5494263581FF77B9E1B5EDA88421698.gr7.eu-west-2.eks.amazonaws.com
      name: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
    contexts:
    - context:
        cluster: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
        namespace: default
        user: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
      name: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
    current-context: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
    kind: Config
    preferences: {}
    users:
    - name: arn:aws:eks:eu-west-2:676312345602:cluster/staging-eks-private
      user:
        exec:
          apiVersion: client.authentication.k8s.io/v1alpha1
          args:
          - --region
          - eu-west-2
          - eks
          - get-token
          - --cluster-name
          - staging-eks-private
          command: aws
          interactiveMode: IfAvailable
          provideClusterInfo: false
---
# Source: pipeline/templates/triggers/role.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: "pipelines-tekton-triggers-cr"
rules:
- apiGroups:
  - tekton.dev
  resources:
  - eventlisteners
  - triggerbindings
  - triggertemplates
  - pipelineresources
  verbs:
  - get
- apiGroups:
  - tekton.dev
  resources:
  - pipelineruns
  - pipelineresources
  verbs:
  - create
- apiGroups:
  - triggers.tekton.dev
  resources:
  - clusterinterceptors
  - clustertriggerbindings
  - interceptors
  verbs:
  - get
  - list
  - watch
---
# Source: pipeline/templates/cronjob.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "cluster-administrator-tekton-cronjob"
subjects:
  - kind: ServiceAccount
    name: "pipelines-tekton-cleanup"
    namespace: tekton-resources
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
---
# Source: pipeline/templates/global/clusterRoleBinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "cluster-administrator-tekton-resources-pipelines"
subjects:
  - kind: ServiceAccount
    name: "pipelines-tekton-default-sa"
    namespace: tekton-resources
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
---
# Source: pipeline/templates/triggers/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "pipelines-tekton-triggers-crb"
subjects:
  - kind: ServiceAccount
    name: "pipelines-tekton-triggers-sa"
    namespace: tekton-resources
roleRef:
  kind: ClusterRole
  name: "pipelines-tekton-triggers-cr"
  apiGroup: rbac.authorization.k8s.io
---
# Source: pipeline/templates/triggers/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: "pipelines-tekton-triggers-role"
  namespace: tekton-resources
rules:
- apiGroups:
  - tekton.dev
  resources:
  - eventlisteners
  - triggerbindings
  - triggertemplates
  - pipelineresources
  verbs:
  - get
- apiGroups:
  - tekton.dev
  resources:
  - pipelineruns
  - pipelineresources
  verbs:
  - create
- apiGroups:
  - triggers.tekton.dev
  resources:
  - triggerbindings
  - triggers
  - triggertemplates
  - eventlisteners
  - clusterinterceptors
  - clustertriggerbindings
  verbs:
  - get
  - list
  - watch
---
# Source: pipeline/templates/triggers/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: "pipelines-tekton-triggers-rb"
  namespace: tekton-resources
subjects:
- kind: ServiceAccount
  name: "pipelines-tekton-triggers-sa"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: "pipelines-tekton-triggers-role"
---
# Source: pipeline/templates/cronjob.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: pipelines-tekton-cleanup
  namespace: tekton-resources
spec:
  schedule: "30 2 * * *"
  startingDeadlineSeconds: 20
  successfulJobsHistoryLimit: 5
  jobTemplate:
    spec:
      completions: 2
      template:
        spec:
          serviceAccountName: "pipelines-tekton-cleanup"
          containers:
          - name: main
            image: bitnami/kubectl
            command: ["sh", "-c"]
            args: ["/configmap/runtimeConfig.sh"]
            volumeMounts:
            - name: configmap
              mountPath: /configmap
          restartPolicy: Never
          volumes:
            - name: configmap
              configMap:
                defaultMode: 0777
                name: pipelines-tekton-cleanup-cm
---
# Source: pipeline/templates/buildah-build/Task.yaml
#ref: https://hub.tekton.dev/tekton/task/buildah
---
# Source: pipeline/templates/custom-task/serviceAccount.yaml
---
---
# Source: pipeline/templates/triggers/eventListener.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: EventListener
metadata:
  name: dev-listener
  namespace: tekton-resources
spec:
  triggers:
    - name: github-listener-prod
      interceptors:
        - ref:
            name: "github"
          params:
            - name: "eventTypes"
              value: [pull_request]
            - name: "overlays"
              value:
              - key: truncated_sha
                expression: "body.pull_request.head.sha.truncate(7)"
              - key: branch_name
                expression: "body.ref"
        - name: "only when specified PR action detected"
          ref:
            name: "cel"
          params:
            - name: "filter"
              value: "body.action in ['opened','synchronize','reopened'] "
      bindings:
        - ref: prod
      template:
        ref: prod
  resources:
    kubernetesResource:
      spec:
        template:
          spec:
            serviceAccountName: "pipelines-tekton-triggers-sa"
            containers:
              - resources:
                  requests:
                    memory: "64Mi"
                    cpu: "250m"
                  limits:
                    memory: "128Mi"
                    cpu: "500m"
---
# Source: pipeline/templates/pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: prod
  namespace: tekton-resources
spec:
  params:


    - default: master
      description: The git revision
      name: git_revision
    - default: git_owner_default_value
      description: The owner of the git revision
      name: git_revision_owner
    - default: git_branch_name_default_value
      description: The name of branch for the git revision
      name: git_branch_name
    - default: git_repository_name_default_value
      description: The name of the git repository
      name: git_repository_name

  workspaces:


    - name: git-pvc
    - name: image-cache
    - name: ssh-creds
    - name: docker-creds-cm

  results:

  tasks:
# Custom Tasks

# / Custom Tasks
# Global task calling

    - name: git-clone
      taskRef:
        name: git-clone
      workspaces:

      - name: ssh-directory
        workspace: ssh-creds
      - name: output
        workspace: git-pvc

      params:
      - name: url
        value: git@github.com:cogitogroupltd/docker-nginx-hello-world
      - name: revision
        value: $(params.git_revision)
    - name: buildah-build-push
      taskRef:
        name: buildah-build
      runAfter: [git-clone]
      workspaces:

      - name: source
        workspace: git-pvc
      - name: dockerconfig
        workspace: docker-creds-cm

      params:
      - name: IMAGE
        value: cogitoexample/docker-nginx-hello-world
    - name: rolling-update
      taskRef:
        name: rolling-update
      runAfter: [buildah-build-push]

      params:
      - name: deployment
        value: nginx-app
      - name: namespace
        value: default
      - name: tag
        value: $(params.git_revision)
      - name: git_repository_name
        value: $(params.git_repository_name)
      - name: docker_registry
        value: cogitoexample
      - name: docker_repository
        value: docker-nginx-hello-world
# / Global Task calling
---
# Source: pipeline/templates/buildah-build/Task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildah-build
  labels:
    app.kubernetes.io/version: "0.5"
  annotations:
    tekton.dev/categories: Image Build
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/tags: image-build
    tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le,linux/arm64"
spec:
  description: >-
    Buildah task builds source into a container image and
    then pushes it to a container registry.

    Buildah Task builds source into a container image using Project Atomic's
    Buildah build tool.It uses Buildah's support for building from Dockerfiles,
    using its buildah bud command.This command executes the directives in the
    Dockerfile to assemble a container image, then pushes that image to a
    container registry.

  params:
  - name: IMAGE
    description: Reference of the image buildah will produce.
  - name: BUILDER_IMAGE
    description: The location of the buildah builder image.
    default: quay.io/buildah/stable:v1.23.3
  - name: STORAGE_DRIVER
    description: Set buildah storage driver
    default: overlay
  - name: DOCKERFILE
    description: Path to the Dockerfile to build.
    default: ./Dockerfile
  - name: CONTEXT
    description: Path to the directory to use as context.
    default: .
  - name: TLSVERIFY
    description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)
    default: "true"
  - name: FORMAT
    description: The format of the built container, oci or docker
    default: "oci"
  - name: BUILD_EXTRA_ARGS
    description: Extra parameters passed for the build command when building images.
    default: ""
  - name: PUSH_EXTRA_ARGS
    description: Extra parameters passed for the push command when pushing images.
    type: string
    default: ""
  - name: SKIP_PUSH
    description: Skip pushing the built image
    default: "false"
  workspaces:
  - name: source
  - name: sslcertdir
    optional: true
  - name: dockerconfig
    description: >-
      An optional workspace that allows providing a .docker/config.json file
      for Buildah to access the container registry.
      The file should be placed at the root of the Workspace with name config.json.
    optional: true
  results:
  - name: IMAGE_DIGEST
    description: Digest of the image just built.
  - name: IMAGE_URL
    description: Image repository where the built image would be pushed to
  steps:
  - name: build
    image: $(params.BUILDER_IMAGE)
    workingDir: $(workspaces.source.path)
    script: |
      [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
      buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) bud \
        $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \
        --tls-verify=$(params.TLSVERIFY) --no-cache \
        -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)
      [[ "$(params.SKIP_PUSH)" == "true" ]] && echo "Push skipped" && exit 0
      [[ "$(workspaces.dockerconfig.bound)" == "true" ]] && export DOCKER_CONFIG="$(workspaces.dockerconfig.path)"
      buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) push \
        $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
        --digestfile /tmp/image-digest $(params.IMAGE) \
        docker://$(params.IMAGE)
      cat /tmp/image-digest | tee $(results.IMAGE_DIGEST.path)
      echo "$(params.IMAGE)" | tee $(results.IMAGE_URL.path)
    volumeMounts:
    - name: varlibcontainers
      mountPath: /var/lib/containers
    securityContext:
      privileged: true
  volumes:
  - name: varlibcontainers
    emptyDir: {}
---
# Source: pipeline/templates/create-webhook/Task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: "pipelines-create-webhook"
  namespace: tekton-resources
spec:
  volumes:
  - name: github-secret
    secret:
      secretName: $(params.GitHubSecretName)
  description: >
    Creates a Github Webhook in a specified repository in order to send GitHub events to EventListeners.
    Run this Task if Pipelines need to be automatically triggered by any event.
  params:
  - name: ExternalDomain
    description: "The external domain for the EventListener e.g. `$(params.EventListenerName).<PROXYIP>.nip.io`"
  - name: GitHubUser
    description: "The GitHub user"
  - name: GitHubRepo
    description: "The GitHub repo where the webhook will be created"
  - name: GitHubOrg
    description: "The GitHub organization where the webhook will be created"
  - name: GitHubSecretName
    description: "The Secret name for GitHub access token. This is always mounted and must exist"
  - name: GitHubAccessTokenKey
    description: "The GitHub access token key name"
  - name: GitHubSecretStringKey
    description: "The GitHub secret string key name"
  - name: GitHubDomain
    description: "The GitHub domain. Override for GitHub Enterprise"
    default: "github.com"
  - name: WebhookEvents
    description: "List of events the webhook will send notifications for"
    default: '["push","pull_request"]'
  steps:
  - name: create-webhook
    image: python:latest
    volumeMounts:
    - name: github-secret
      mountPath: /var/secret
    command:
    - sh
    args:
    - -ce
    - |
      set -e
      set -x
      echo "Creating Webhook"
      pip install kubernetes
      python3 - <<'EOF'
      from kubernetes import client,config
      import os
      import base64
      import requests
      import json

      # Authenticate with k8s cluster
      config.load_incluster_config()

      # Read Github token
      with open('/var/secret/$(params.GitHubAccessTokenKey)', 'r') as file:
        token = file.read().replace('\n', '')
      
      # create Github webhook and return id
      Headers = { "Accept" : "application/vnd.github.v3+json", "Authorization": "token %s" % token}
      data = '{"name": "web","active": true,"events": $(params.WebhookEvents) ,"config": {"url": "https://$(params.ExternalDomain)","content_type": "json","insecure_ssl": "1" }}'
      if "$(params.GitHubDomain)" == "github.com":
        x = requests.post('https://api.github.com/repos/$(params.GitHubOrg)/$(params.GitHubRepo)/hooks', data=data, headers=Headers)
      print(x.text)
      json_response=json.loads(x.text)
      webhook_id=str(json_response['id'])
      # Encode Hook ID as base64 to save in configMap
      urlSafeEncodedBytes = base64.urlsafe_b64encode(webhook_id.encode("utf-8"))
      urlSafeEncodedStr = str(urlSafeEncodedBytes, "utf-8")

      # Create ConfigMap containing ID for the delete-webhook job
      api_instance = client.CoreV1Api()
      delete=False
      try:
          api_response = api_instance.list_namespaced_config_map(namespace="tekton-resources", label_selector='metadata.name=pipelines-create-webhook',timeout_seconds="2")
          print(len(api_response.items))
          if len(api_response.items) == 1 :
            delete=True
          # print(api_response)
      except Exception as e:
          print("No configMap found, creating pipelines to store Webhook ID")
      if delete:
        api_response = api_instance.delete_namespaced_config_map(name="pipelines-create-webhook", namespace="tekton-resources")  
      api_instance.create_namespaced_config_map(
          body=client.V1ConfigMap(
              metadata=client.V1ObjectMeta(
                  name="pipelines-create-webhook",
                  namespace="tekton-resources"
              ),
              data={
                  "id": urlSafeEncodedStr
              }
          ),
          namespace="tekton-resources"
      )
      print("Created configMap pipelines with Webhook id=%s" % webhook_id)
      EOF
---
# Source: pipeline/templates/delete-webhook/Task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: "pipelines-delete-webhook"
  namespace: tekton-resources
spec:
  description: >-
    This Tasks works with repository webhooks which are used to trigger Tekton Pipelines.

    The create-webhook Task will create a webhook and store the webhook ID in a configMap. 
    The configmap is solely used by the delete-webhook task.

  volumes:
  - name: github-secret
    secret:
      secretName: $(params.GitHubSecretName)
  params:
  - name: ExternalDomain
    description: "The external domain for the EventListener e.g. `$(params.EventListenerName).<PROXYIP>.nip.io`"
  - name: GitHubUser
    description: "The GitHub user"
  - name: GitHubRepo
    description: "The GitHub repo where the webhook will be created"
  - name: GitHubOrg
    description: "The GitHub organization where the webhook will be created"
  - name: GitHubSecretName
    description: "The Secret name for GitHub access token. This is always mounted and must exist"
  - name: GitHubAccessTokenKey
    description: "The GitHub access token key name"
  - name: GitHubSecretStringKey
    description: "The GitHub secret string key name"
  - name: GitHubDomain
    description: "The GitHub domain. Override for GitHub Enterprise"
    default: "github.com"
  - name: WebhookEvents
    description: "List of events the webhook will send notifications for"
    default: '["push","pull_request"]'
  steps:
  - name: create-webhook
    image: python
    volumeMounts:

    - name: github-secret
      mountPath: /var/secret

    command:
    - sh
    args:
    - -ce
    - |
      set -e
      set -x
      echo "Deleting Webhook"
      pip install kubernetes
      
      python3 - <<'EOF'
      from kubernetes import client,config
      import os
      import requests
      import base64
      import json
      # Authenticate with k8s cluster
      config.load_incluster_config()

      with open('/var/secret/$(params.GitHubAccessTokenKey)', 'r') as file:
        token = file.read().replace('\n', '')
      
      # Retrieve webhook id from configmap
      api_instance = client.CoreV1Api()
      try: 
        api_response = api_instance.read_namespaced_config_map(namespace="tekton-resources", name=("%s" % os.getenv("$(params.GitHubSecretName)","pipelines-create-webhook")))
        webhook_id_b64=api_response.data["id"]
        webhook_id=base64.b64decode(webhook_id_b64).decode("utf-8")
        
      except Exception as e:
        print("Exception when calling CoreV1Api->read_namespaced_config_map: %s\n" % e)

      # Send request to delete the webhook
      Headers = { "Accept" : "application/vnd.github.v3+json", "Authorization": "token %s" % token}

      if "$(params.GitHubDomain)" == "github.com":
        x = requests.delete("https://api.github.com/repos/$(params.GitHubOrg)/$(params.GitHubRepo)/hooks/%s" % webhook_id, headers=Headers)
        if x.status_code != 204:
          print("Failed deleting webhook, status code %s" % x.status_code)
      else:
        x = requests.delete("https://$(params.GitHubDomain)/api/v3/repos/$(params.GitHubOrg)/$(params.GitHubRepo)/hooks/%s" % webhook_id, headers=Headers)
        if x.status_code != 204:
          print("Failed deleting webhook, status code %s" % x.status_code)
      print("deleted webhook_id: %s" % webhook_id)
      # Delete configMap containing webhook_id
      try:
          api_response = api_instance.list_namespaced_config_map(namespace="tekton-resources", label_selector='metadata.name=pipelines-create-webhook',timeout_seconds="2")
          delete=True
      except Exception as e:
          print("No configMap found called pipelines")
      if delete:
        api_response = api_instance.delete_namespaced_config_map(name="pipelines-create-webhook", namespace="tekton-resources")  
      EOF
---
# Source: pipeline/templates/git-clone/task.yaml
#ref: https://hub.tekton.dev/tekton/task/git-clone
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: "git-clone"
  namespace: tekton-resources
  labels:
    app.kubernetes.io/version: "0.5"
  annotations:
    tekton.dev/pipelines.minVersion: "0.21.0"
    tekton.dev/categories: Git
    tekton.dev/tags: git
    tekton.dev/displayName: "git clone"
    tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le,linux/arm64"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.

    The git-clone Task will clone a repo from the provided url into the
    output Workspace. By default the repo will be cloned into the root of
    your Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param. This Task also supports sparse checkouts. To perform
    a sparse checkout, pass a list of comma separated directory patterns to
    this Task's sparseCheckoutDirectories param.
  workspaces:
    - name: output
      description: The git repo will be cloned onto the volume backing this Workspace.
    - name: ssh-directory
      optional: true
      description: |
        A .ssh directory with private key, known_hosts, config, etc. Copied to
        the user's home before git commands are executed. Used to authenticate
        with the git remote when performing the clone. Binding a Secret to this
        Workspace is strongly recommended over other volume types.
    - name: basic-auth
      optional: true
      description: |
        A Workspace containing a .gitconfig and .git-credentials file. These
        will be copied to the user's home before any git commands are run. Any
        other files in this Workspace are ignored. It is strongly recommended
        to use ssh-directory over basic-auth whenever possible and to bind a
        Secret to this Workspace over other volume types.
    - name: ssl-ca-directory
      optional: true
      description: |
        A workspace containing CA certificates, this will be used by Git to
        verify the peer with when fetching or pushing over HTTPS.
  params:
    - name: url
      description: Repository URL to clone from.
      type: string
    - name: revision
      description: Revision to checkout. (branch, tag, sha, ref, etc...)
      type: string
      default: ""
    - name: refspec
      description: Refspec to fetch before checking out revision.
      default: ""
    - name: submodules
      description: Initialize and fetch git submodules.
      type: string
      default: "true"
    - name: depth
      description: Perform a shallow clone, fetching only the most recent N commits.
      type: string
      default: "1"
    - name: sslVerify
      description: Set the `http.sslVerify` global git config. Setting this to `false` is not advised unless you are sure that you trust your git remote.
      type: string
      default: "true"
    - name: subdirectory
      description: Subdirectory inside the `output` Workspace to clone the repo into.
      type: string
      default: ""
    - name: sparseCheckoutDirectories
      description: Define the directory patterns to match or exclude when performing a sparse checkout.
      type: string
      default: ""
    - name: deleteExisting
      description: Clean out the contents of the destination directory if it already exists before cloning.
      type: string
      default: "true"
    - name: httpProxy
      description: HTTP proxy server for non-SSL requests.
      type: string
      default: ""
    - name: httpsProxy
      description: HTTPS proxy server for SSL requests.
      type: string
      default: ""
    - name: noProxy
      description: Opt out of proxying HTTP/HTTPS requests.
      type: string
      default: ""
    - name: verbose
      description: Log the commands that are executed during `git-clone`'s operation.
      type: string
      default: "true"
    - name: gitInitImage
      description: The image providing the git-init binary that this Task runs.
      type: string
      default: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0"
    - name: userHome
      description: |
        Absolute path to the user's home directory. Set this explicitly if you are running the image as a non-root user or have overridden
        the gitInitImage param with an image containing custom user configuration.
      type: string
      default: "/tekton/home"
  results:
    - name: commit
      description: The precise commit SHA that was fetched by this Task.
    - name: url
      description: The precise URL that was fetched by this Task.
    - name: revision
      description: Revision of git repository pulled down (branch, tag, sha, ref, etc...).
  steps:
    - name: clone
      image: "$(params.gitInitImage)"
      env:
      - name: HOME
        value: "$(params.userHome)"
      - name: PARAM_URL
        value: $(params.url)
      - name: PARAM_REVISION
        value: $(params.revision)
      - name: PARAM_REFSPEC
        value: $(params.refspec)
      - name: PARAM_SUBMODULES
        value: $(params.submodules)
      - name: PARAM_DEPTH
        value: $(params.depth)
      - name: PARAM_SSL_VERIFY
        value: $(params.sslVerify)
      - name: PARAM_SUBDIRECTORY
        value: $(params.subdirectory)
      - name: PARAM_DELETE_EXISTING
        value: $(params.deleteExisting)
      - name: PARAM_HTTP_PROXY
        value: $(params.httpProxy)
      - name: PARAM_HTTPS_PROXY
        value: $(params.httpsProxy)
      - name: PARAM_NO_PROXY
        value: $(params.noProxy)
      - name: PARAM_VERBOSE
        value: $(params.verbose)
      - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
        value: $(params.sparseCheckoutDirectories)
      - name: PARAM_USER_HOME
        value: $(params.userHome)
      - name: WORKSPACE_OUTPUT_PATH
        value: $(workspaces.output.path)
      - name: WORKSPACE_SSH_DIRECTORY_BOUND
        value: $(workspaces.ssh-directory.bound)
      - name: WORKSPACE_SSH_DIRECTORY_PATH
        value: $(workspaces.ssh-directory.path)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
        value: $(workspaces.basic-auth.bound)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
        value: $(workspaces.basic-auth.path)
      - name: WORKSPACE_SSL_CA_DIRECTORY_BOUND
        value: $(workspaces.ssl-ca-directory.bound)
      - name: WORKSPACE_SSL_CA_DIRECTORY_PATH
        value: $(workspaces.ssl-ca-directory.path)
      script: |
        #!/usr/bin/env sh
        set -eu

        if [ "${PARAM_VERBOSE}" = "true" ] ; then
          set -x
        fi


        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ] ; then
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials" "${PARAM_USER_HOME}/.git-credentials"
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig" "${PARAM_USER_HOME}/.gitconfig"
          chmod 400 "${PARAM_USER_HOME}/.git-credentials"
          chmod 400 "${PARAM_USER_HOME}/.gitconfig"
        fi

        if [ "${WORKSPACE_SSH_DIRECTORY_BOUND}" = "true" ] ; then
          cp -R "${WORKSPACE_SSH_DIRECTORY_PATH}" "${PARAM_USER_HOME}"/.ssh
          chmod 700 "${PARAM_USER_HOME}"/.ssh
          chmod -R 400 "${PARAM_USER_HOME}"/.ssh/*
        fi

        if [ "${WORKSPACE_SSL_CA_DIRECTORY_BOUND}" = "true" ] ; then
           export GIT_SSL_CAPATH="${WORKSPACE_SSL_CA_DIRECTORY_PATH}"
        fi
        CHECKOUT_DIR="${WORKSPACE_OUTPUT_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf ${CHECKOUT_DIR}" because ${CHECKOUT_DIR} might be "/"
          # or the root of a mounted volume.
          if [ -d "${CHECKOUT_DIR}" ] ; then
            # Delete non-hidden files and directories
            rm -rf "${CHECKOUT_DIR:?}"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "${CHECKOUT_DIR}"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "${CHECKOUT_DIR}"/..?*
          fi
        }

        if [ "${PARAM_DELETE_EXISTING}" = "true" ] ; then
          cleandir
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        /ko-app/git-init \
          -url="${PARAM_URL}" \
          -revision="${PARAM_REVISION}" \
          -refspec="${PARAM_REFSPEC}" \
          -path="${CHECKOUT_DIR}" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth="${PARAM_DEPTH}" \
          -sparseCheckoutDirectories="${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "${CHECKOUT_DIR}"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "${EXIT_CODE}" != 0 ] ; then
          exit "${EXIT_CODE}"
        fi
        printf "%s" "${RESULT_SHA}" > "$(results.commit.path)"
        printf "%s" "${PARAM_URL}" > "$(results.url.path)"
        printf "%s" "${PARAM_REVISION}" > "$(results.revision.path)"
---
# Source: pipeline/templates/kaniko-build/task.yaml
# https://hub.tekton.dev/tekton/task/kaniko
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: "kaniko-build"
  namespace: tekton-resources
  labels:
    app.kubernetes.io/version: "0.5"
  annotations:
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/categories: Image Build
    tekton.dev/tags: image-build
    tekton.dev/displayName: "Build and upload container image using Kaniko"
    tekton.dev/platforms: "linux/amd64"
spec:
  description: >-
    This Task builds source into a container image using Google's kaniko tool.

    Kaniko doesn't depend on a Docker daemon and executes each
    command within a Dockerfile completely in userspace. This enables
    building container images in environments that can't easily or
    securely run a Docker daemon, such as a standard Kubernetes cluster.

  params:
  - name: DOCKER_IMAGE_TAG
    description: Tag (reference) of the image to build 
  - name: DOCKER_REGISTRY
    description: Name (reference) of the registry storing the image to build.
  - name: DOCKER_REPOSITORY
    description: Name (reference) of the image to build.
  - name: DOCKERFILE
    description: Path to the Dockerfile to build.
    default: ./Dockerfile
  - name: CONTEXT
    description: The build context used by Kaniko.
    default: ./
  - name: EXTRA_ARGS
    type: array
    default: []
  - name: BUILDER_IMAGE
    description: The image on which builds will run (default is v1.5.1)
    default: gcr.io/kaniko-project/executor:v1.7.0@sha256:8504bde9a9a8c9c4e9a4fe659703d265697a36ff13607b7669a4caa4407baa52
  workspaces:
  - name: git-pvc
    description: Holds the context and docker file
  - name: dockerconfig
    description: Includes a docker `config.json`
    optional: true
    mountPath: /kaniko/.docker
  - name: image-cache
    description: directory for loading image caches across builds
    optional: true
    mountPath: /cache
  results:
  - name: IMAGE-DIGEST
    description: Digest of the image just built.
  steps:
  - name: build-and-push
    workingDir: $(workspaces.git-pvc.path)
    image: $(params.BUILDER_IMAGE)
    args:
    - $(params.EXTRA_ARGS[*])
    - --dockerfile=$(params.DOCKERFILE)
    - --context=$(params.CONTEXT)  # The user does not need to care the workspace and the source.
    - --destination=$(params.DOCKER_REGISTRY)/$(params.DOCKER_REPOSITORY):$(params.DOCKER_IMAGE_TAG)
    - --cache=true
    - --digest-file=/tekton/results/IMAGE-DIGEST
    - --cache-dir=/cache
    - --reproducible
    # kaniko assumes it is running as root, which means this example fails on platforms
    # that default to run containers as random uid (like OpenShift). Adding this securityContext
    # makes it explicit that it needs to run as root.
    securityContext:
      runAsUser: 0
---
# Source: pipeline/templates/rolling-update/task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: rolling-update
  namespace: tekton-resources
  labels:
    app.kubernetes.io/version: "0.2"
  annotations:
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/categories: Kubernetes
    tekton.dev/tags: CLI, kubectl
    tekton.dev/displayName: "kubernetes actions"
    tekton.dev/platforms: "linux/amd64"
spec:
  workspaces:
    - name: kubeconfig-dir
      optional: true
  params:
    - name: deployment
      type: string
    - name: namespace
      type: string
      default: "default"
    - name: git_repository_name
      type: string
      default: "defaultgitrepositoryname"
    - name: docker_registry
      type: string
      default: "defaultdockerregistry"
    - name: docker_repository
      type: string
      default: "defaultdockerrepo"
    - name: tag
      type: string
      default: "master"
  steps:
    - name: rolling-update
      image: cogitoexample/cicd-agent:0.02
      script: |
        set -xe
        kubectl get deployment $(params.deployment) --namespace $(params.namespace) | grep -iq "$(params.deployment)" || kubectl create deployment $(params.deployment) --namespace $(params.namespace) --image="$(params.docker_registry)/$(params.docker_repository):$(params.tag)"
        # The set image command has this syntax `kubectl set image deploy/$DEPLOYMENT_NAME $CONTAINER_NAME=cogitoexample/docker-nginx-hello-world --namespace default`
        kubectl set image deploy/$(params.deployment) "$(params.docker_repository)=$(params.docker_registry)/$(params.docker_repository):$(params.tag)" --namespace $(params.namespace)
        kubectl rollout restart deployment/$(params.deployment) --namespace $(params.namespace)
        kubectl rollout status deployment/$(params.deployment) --namespace $(params.namespace)
---
# Source: pipeline/templates/send-to-webhook-slack/task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: send-to-webhook-slack
  namespace: tekton-resources
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/categories: Messaging
    tekton.dev/tags: messaging
    tekton.dev/displayName: "Send message to Slack Channel"
    tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le"
spec:
  description: >-
    These tasks post a simple message to a slack channel.

    This task uses Incoming Webhooks of slack to send the message.

  params:
  - name: webhook-secret
    type: string
    description: secret name of the slack app webhook URL (key is url)
  - name: message
    type: string
    description: plain text message
  - name: log_level
    type: string
    description: plain text for log_level verbosity eg. INFO, WARNING, ERROR
    default: 'INFO'
  - name: git_revision_owner
    type: string
    description: The owner of the git revision
  - name: helm_release_name
    type: string
    description: The name of the helm release for the pipeline
  - name: pipeline_name
    type: string
    description: The name of the Tekton pipeline
  - name: git_repository_name
    type: string
    description: The name of the git repository
  - name: bot-name
    type: string
    description: plain text message
    default: 'Tekton Bot'
  - name: icon-emoji
    type: string
    description: plain text message
    default: ':robot_face:'
  steps:
  - name: post
    image: docker.io/curlimages/curl:7.70.0@sha256:031df77a11e5edded840bc761a845eab6e3c2edee22669fb8ad6d59484b6a1c4 #tag: 7.70.0
    script: |
      #!/usr/bin/env sh
      MESSAGE=$(echo "$(date '+%Y-%m-%d-%H:%M%:S') ${LOG_LEVEL} [${GIT_REVISION_OWNER}] [${HELM_RELEASE_NAME}] [${GIT_REPOSITORY_NAME}] [${PIPELINE_NAME}] ${MESSAGE}" | sed -e 's/\"/\\\\"/g')
      BOTNAME=$(echo "${BOTNAME}" | sed -e 's/\"/\\\\"/g')
      JSON="{\"text\": \"${MESSAGE}\", \"username\": \"${BOTNAME}\", \"icon_emoji\": \"${EMOJI}\"}"
      curl -X POST -H 'Content-Type: application/json' --data "${JSON}" "${URL}"
    env:
    - name: URL
      valueFrom:
        secretKeyRef:
          name: $(params.webhook-secret)
          key: url
    - name: MESSAGE
      value: $(params.message)
    - name: BOTNAME
      value: $(params.bot-name)
    - name: GIT_REVISION_OWNER
      value: $(params.git_revision_owner)
    - name: PIPELINE_NAME
      value: $(params.pipeline_name)
    - name: GIT_REPOSITORY_NAME
      value: $(params.git_repository_name)
    - name: HELM_RELEASE_NAME
      value: $(params.helm_release_name)
    - name: EMOJI
      value: $(params.icon-emoji)
    - name: LOG_LEVEL
      value: $(params.log_level)
---
# Source: pipeline/templates/triggers/trigger.yaml
apiVersion: triggers.tekton.dev/v1alpha1
kind: Trigger
metadata:
  name: prod
  namespace: tekton-resources
spec:
  interceptors:
    - ref:
        name: "cel"
  bindings:
  - ref: prod
  template:
    ref: prod
---
# Source: pipeline/templates/triggers/triggerBinding.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerBinding
metadata:
  name: prod
  namespace: tekton-resources
spec:
  params:
  - name: git_revision



    value: $(body.pull_request.head.sha)







  - name: namespace
    value: default
  - name: git_source
    value: $(body.repository.html_url)
  - name: git_repository_name
    value: $(body.repository.name)
  - name: git_branch_name
    value: $(body.ref)
  - name: git_revision_owner
---
# Source: pipeline/templates/triggers/triggerTemplate.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerTemplate
metadata:
  name: prod
  namespace: 
spec:
  params:
  - name: git_revision
    description: The git revision
  - name: git_revision_owner
    description: The owner of the git revision
  - name: git_repository_name
    description: The name of the git repository
  - name: git_branch_name
    description: The name of the git repository
  - name: url
    description: The git repository url
  resourcetemplates:
  - apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: prod-$(uid)
    spec:
      
      pipelineRef:
        name: prod
      serviceAccountNames:
        
      params:
      - name: git_revision
        value: $(tt.params.git_revision)
      - name: git_revision_owner
        value: $(tt.params.git_revision_owner)
      - name: git_branch_name
        value: $(tt.params.git_branch_name)
      workspaces:
        - name: git-pvc
          volumeClaimTemplate:
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 10Gi
        - name: image-cache
          volumeClaimTemplate:
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 10Gi
        - name: ssh-creds
          secret:
            secretName: "pipelines-ssh-key"
        - name: docker-creds-cm
          secret:
            secretName: "pipelines-docker-config"
        - name: kubeconfig
          configMap:
            name: "pipelines-kube-config"
